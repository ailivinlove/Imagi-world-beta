
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Imagi-world (Da Vinci iOS)</title>
    <style>
        :root {
            --bg: #0b0c10;
            --panel: #1f2833;
            --input: #c5c6c7;
            --accent: #45a29e;
            --highlight: #66fcf1;
            --text: #e6e6e6;
            --success: #2ecc71;
            --danger: #e74c3c;
            --beta: #ff0033;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        /* Scanline Overlay */
        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
        }

        h1 { 
            margin: 20px 0; 
            font-size: 1.8rem; 
            text-align: center; 
            letter-spacing: -1px; 
            text-transform: uppercase; 
        }

        .beta-tag {
            color: var(--beta);
            font-weight: 900;
            font-style: italic;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; text-shadow: 0 0 15px var(--beta); } 100% { opacity: 0.8; } }

        .container { max-width: 900px; width: 100%; z-index: 1; }

        .controls {
            background: var(--panel);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #45a29e33;
            box-shadow: 0 0 20px rgba(69, 162, 158, 0.1);
        }

        .control-group { margin-bottom: 20px; }
        label { display: flex; justify-content: space-between; margin-bottom: 8px; font-weight: 700; font-size: 0.85rem; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; }

        input[type="range"] {
            width: 100%;
            accent-color: var(--highlight);
            height: 20px; /* Taller for touch */
            background: #333;
            border-radius: 10px;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 24px; height: 24px; background: var(--highlight); border-radius: 50%; cursor: pointer;
        }

        input[type="number"] {
            background: #111; border: 1px solid #444; color: var(--highlight); padding: 12px; font-family: inherit; width: 100%; font-size: 1.2rem;
        }

        .button-group { display: flex; gap: 15px; margin-top: 30px; }

        button {
            background: transparent;
            color: var(--highlight);
            border: 1px solid var(--highlight);
            padding: 15px 10px;
            font-size: 1rem;
            font-family: inherit;
            font-weight: 700;
            cursor: pointer;
            flex: 1;
            text-transform: uppercase;
            transition: all 0.2s;
            touch-action: manipulation; /* Improves iOS tap response */
        }
        button:hover:not(:disabled) { background: var(--highlight); color: var(--bg); box-shadow: 0 0 15px var(--highlight); }
        button:disabled { border-color: #444; color: #666; cursor: not-allowed; }
        
        button.danger { border-color: var(--danger); color: var(--danger); }
        button.danger:hover:not(:disabled) { background: var(--danger); color: white; box-shadow: 0 0 15px var(--danger); }

        .game-area {
            background: var(--panel);
            padding: 40px 20px;
            border-radius: 8px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #45a29e33;
            position: relative;
        }

        .premise-display {
            font-size: 1.5rem;
            color: #fff;
            margin: 20px 0;
            line-height: 1.4;
            font-weight: 600;
            min-height: 80px;
            max-width: 95%;
            opacity: 0; 
            transition: opacity 0.1s ease-out; 
            will-change: opacity;
        }

        .status { position: absolute; top: 15px; left: 20px; font-size: 0.7rem; color: #666; text-transform: uppercase; }

        .feedback { 
            height: 40px; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 1.5rem; 
            font-weight: 900; 
            text-transform: uppercase; 
            letter-spacing: 2px;
        }
        .feedback.correct { color: var(--success); text-shadow: 0 0 10px var(--success); }
        .feedback.incorrect { color: var(--danger); text-shadow: 0 0 10px var(--danger); }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            background: #45a29e33;
            margin-top: 20px;
            border: 1px solid #45a29e33;
        }
        .stat-box { background: var(--panel); padding: 15px; text-align: center; }
        .stat-val { font-size: 1.6rem; font-weight: 700; color: var(--text); }
        .stat-lbl { font-size: 0.6rem; color: var(--accent); letter-spacing: 1px; text-transform: uppercase; margin-bottom: 5px; }

        #runtime-diagnostics-panel {
            margin-top: 15px;
            font-size: 0.75rem;
            color: #555;
            border-top: 1px solid #333;
            padding-top: 10px;
            font-family: monospace;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

<main class="container">
    <h1>Imagi-world <span class="beta-tag">BETA</span></h1>

    <div class="controls">
        <div class="control-group">
            <label>N-Back Level (Load) <span id="n-value" style="color:var(--highlight)">1</span></label>
            <input type="range" id="n-slider" min="1" max="12" value="1">
        </div>

        <div class="control-group">
            <label>Chain Length (Atoms) <span id="k-value" style="color:var(--highlight)">1</span></label>
            <input type="range" id="k-slider" min="1" max="8" value="1">
        </div>

        <div class="control-group">
            <label>Time Pressure (Seconds) <span id="spt-value" style="color:var(--highlight)">4.0</span>s</label>
            <input type="range" id="spt-slider" min="1.5" max="20" step="0.5" value="4.0">
        </div>
        
        <div class="control-group">
             <label>Total Trials</label>
             <input type="number" id="numTrialsInput" value="20" min="5" max="1000">
        </div>

        <div class="button-group">
            <button id="start-btn">INITIATE SEQUENCE</button>
            <button id="stop-btn" class="danger" disabled>ABORT</button>
        </div>

        <div id="runtime-diagnostics-panel">
            <span id="diag-status">SYSTEM IDLE</span>
            <span id="diag-meta">Turn off Silent Switch</span>
        </div>
    </div>

    <div class="game-area">
        <div class="status" id="status">READY</div>
        <div class="premise-display" id="premise-display">Awaiting Initialization</div>
        <div class="feedback" id="feedback"></div>

        <div class="response-buttons" style="margin-top:20px; display:flex; gap:20px;">
            <button id="match-btn" disabled>MATCH</button>
            <button id="no-match-btn" disabled>NO MATCH</button>
        </div>
    </div>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-lbl">Trial</div>
            <div class="stat-val" id="trial-count">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-lbl">Score</div>
            <div class="stat-val" id="score">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-lbl">Accuracy</div>
            <div class="stat-val" id="accuracy">--</div>
        </div>
    </div>
</main>

<script>
/**
 * IMAGI-WORLD ENGINE: DA VINCI ARCHITECTURE (iOS NATIVE)
 * 
 * 1. Hard Audio Unlock: Forces speech on immediate click event.
 * 2. Logic: Strict Path Reversal (Da Vinci).
 * 3. Sync: Instant visual trigger on audio start.
 */

const RELATIONS = {
    'N': 'North', 'S': 'South', 'E': 'East', 'W': 'West',
    'NE': 'North-East', 'NW': 'North-West', 'SE': 'South-East', 'SW': 'South-West'
};
const AXES = Object.keys(RELATIONS);

class RNG {
    constructor() { this.seed = Date.now(); }
    next() {
        let t = (this.seed += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
    choice(arr) { return arr[Math.floor(this.next() * arr.length)]; }
    shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(this.next() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }
}

class Atom {
    constructor(axis, head, tail) {
        this.axis = axis; this.head = head; this.tail = tail;
    }
    toString() { return `${this.head} is ${RELATIONS[this.axis]} of ${this.tail}`; }
    toKey() { return `${this.axis}:${this.head}:${this.tail}`; }
}

class Premise {
    constructor(atoms, type = 'standard') {
        this.atoms = atoms;
        this.type = type;
    }
    toString() {
        if (this.atoms.length > 1) {
            return this.atoms.map(a => a.toString()).join('; and ');
        }
        return this.atoms[0].toString();
    }
}

class AdvancedGenerator {
    constructor(rng) {
        this.rng = rng;
        this.letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
        this.recentLetters = [];
    }

    getOpposite(axis) {
        const map = { 'N':'S', 'S':'N', 'E':'W', 'W':'E', 'NE':'SW', 'SW':'NE', 'NW':'SE', 'SE':'NW' };
        return map[axis];
    }

    getPool(count) {
        let pool = [];
        if (this.recentLetters.length > 0) {
            const reuseCount = Math.floor(count / 2);
            const recentShuffled = this.rng.shuffle([...this.recentLetters]);
            pool.push(...recentShuffled.slice(0, reuseCount));
        }
        const fresh = this.rng.shuffle(this.letters.filter(l => !pool.includes(l)));
        while (pool.length < count) pool.push(fresh.pop());
        this.recentLetters = pool;
        return this.rng.shuffle(pool);
    }

    generate(k, matchTarget = null) {
        if (matchTarget) return this.buildMatch(matchTarget);
        return this.buildNew(k);
    }

    buildNew(k) {
        const pool = this.getPool(k + 1);
        const atoms = [];
        for (let i = 0; i < k; i++) {
            const head = pool[i];
            const tail = pool[i+1];
            const axis = this.rng.choice(AXES);
            atoms.push(new Atom(axis, head, tail));
        }
        return new Premise(atoms);
    }

    buildMatch(target) {
        // Strict Path Reversal
        const atoms = [];
        for (let i = target.atoms.length - 1; i >= 0; i--) {
            const a = target.atoms[i];
            atoms.push(new Atom(this.getOpposite(a.axis), a.tail, a.head));
        }
        return new Premise(atoms, 'match');
    }

    buildLure(target) {
        const atoms = target.atoms.map(a => {
            const r = this.rng.next();
            if (r < 0.3) return new Atom(this.rng.choice(AXES.filter(x => x !== a.axis)), a.head, a.tail);
            if (r < 0.6) return new Atom(a.axis, a.tail, a.head);
            return new Atom(a.axis, a.head, a.tail);
        });
        if (atoms.every((a, i) => a.toKey() === target.atoms[i].toKey())) {
            atoms[0].axis = this.rng.choice(AXES.filter(x => x !== atoms[0].axis));
        }
        return new Premise(atoms, 'lure');
    }
}

class GameEngine {
    constructor() {
        this.rng = new RNG();
        this.gen = new AdvancedGenerator(this.rng);
        this.history = [];
        this.n = 1;
        this.k = 1;
        this.spt = 4.0;
        this.running = false;
        this.abortCtrl = null;
        this.score = 0;
        this.synth = window.speechSynthesis;
    }

    /**
     * SPEAK SYNCHRONIZED (iOS OPTIMIZED)
     */
    speakSynchronized(text) {
        const display = document.getElementById('premise-display');
        
        // 1. Hide
        display.style.transition = 'none';
        display.style.opacity = '0';
        display.innerText = text;
        void display.offsetWidth;
        
        // 2. Prep Fade
        display.style.transition = 'opacity 0.1s ease-out';

        // 3. Audio Setup
        this.synth.cancel(); // Flush queue
        const u = new SpeechSynthesisUtterance(text);
        
        // iOS Voice Handling: Don't be picky, just get English
        const voices = this.synth.getVoices();
        const preferred = voices.find(v => v.name.includes('Samantha')) || 
                          voices.find(v => v.name.includes('Daniel')) || 
                          voices.find(v => v.lang.startsWith('en'));
        
        if(preferred) u.voice = preferred;
        u.rate = 1.15; 
        u.pitch = 1.0;
        u.volume = 1.0; // Force max volume

        // 4. Sync: Show text EXACTLY when audio hardware engages
        u.onstart = () => {
            display.style.opacity = '1';
        };

        this.synth.speak(u);
    }

    speakPlain(text) {
         this.synth.cancel();
         const u = new SpeechSynthesisUtterance(text);
         u.rate = 1.15;
         u.volume = 1.0;
         this.synth.speak(u);
    }

    async vocalCountdown() {
        const display = document.getElementById('premise-display');
        display.style.transition = 'none';
        display.style.opacity = '0';
        void display.offsetWidth;
        display.style.color = 'var(--highlight)';
        display.style.fontSize = "3rem";
        display.style.opacity = '1';

        const count = ["Three", "Two", "One"];
        for (let num of count) {
            display.innerText = num === "Three" ? "3" : (num === "Two" ? "2" : "1");
            this.speakPlain(num);
            await new Promise(r => setTimeout(r, 1000));
        }

        display.style.opacity = '0';
        await new Promise(r => setTimeout(r, 200));
        display.innerText = "";
        display.style.fontSize = "";
        display.style.color = "#fff";
    }

    async runSession(totalTrials) {
        this.running = true;
        this.abortCtrl = new AbortController();
        this.history = [];
        this.score = 0;
        
        document.getElementById('start-btn').disabled = true;
        document.getElementById('stop-btn').disabled = false;
        document.getElementById('status').innerText = "INITIALIZING...";
        document.getElementById('score').innerText = "0";
        document.getElementById('accuracy').innerText = "--";

        try {
            // Countdown handles the engine warm-up
            await this.vocalCountdown();

            document.getElementById('status').innerText = "SEQUENCE RUNNING";

            for (let i = 0; i < totalTrials; i++) {
                if (this.abortCtrl.signal.aborted) break;
                
                const trialStart = Date.now();
                
                // Logic
                let isMatch = (i >= this.n) && (this.rng.next() > 0.65);
                const target = isMatch ? this.history[i - this.n] : null;
                let premise;
                let trialTypeDebug = "";

                if (isMatch) {
                    premise = this.gen.generate(this.k, target);
                    trialTypeDebug = "MATCH (INVERTED)";
                } else {
                    if (i >= this.n && this.rng.next() > 0.4) {
                        premise = this.gen.buildLure(this.history[i - this.n]);
                        trialTypeDebug = "LURE";
                    } else {
                        premise = this.gen.buildNew(this.k);
                        trialTypeDebug = "NEW";
                    }
                }
                
                this.history.push(premise);
                
                // Metadata
                document.getElementById('trial-count').innerText = i + 1;
                document.getElementById('diag-status').innerText = `TRIAL ${i+1}`;
                document.getElementById('diag-meta').innerText = `${trialTypeDebug}`;

                // SYNCED PRESENTATION
                this.speakSynchronized(premise.toString());
                
                // Input
                const userAction = await this.waitForInput(this.spt * 1000, this.abortCtrl.signal);
                
                // Scoring
                if (!this.abortCtrl.signal.aborted) {
                    let correct = false;
                    if (isMatch && userAction === 'match') correct = true;
                    if (!isMatch && userAction === 'nomatch') correct = true;
                    
                    const fb = document.getElementById('feedback');
                    if (userAction === 'timeout') {
                         fb.innerText = "MISS"; fb.className = "feedback incorrect";
                    } else if (correct) {
                        this.score++; fb.innerText = "HIT"; fb.className = "feedback correct";
                    } else {
                        fb.innerText = "ERR"; fb.className = "feedback incorrect";
                    }
                    
                    document.getElementById('score').innerText = this.score;
                    const acc = Math.round((this.score / (i+1)) * 100);
                    document.getElementById('accuracy').innerText = acc + "%";
                }

                // Pacing
                const elapsed = Date.now() - trialStart;
                const targetDur = this.spt * 1000;
                if (elapsed < targetDur) {
                    await new Promise(r => setTimeout(r, targetDur - elapsed));
                }
            }
        } catch (e) {
            console.log("Session end", e);
        } finally {
            this.endSession();
        }
    }

    waitForInput(ms, signal) {
        return new Promise((resolve) => {
            let resolved = false;
            let timerId = null;

            const cleanup = () => {
                // Clean up listeners
                const btnM = document.getElementById('match-btn');
                const btnN = document.getElementById('no-match-btn');
                if(btnM) { btnM.onclick = null; btnM.disabled = true; }
                if(btnN) { btnN.onclick = null; btnN.disabled = true; }
                if (timerId) clearTimeout(timerId);
            };

            const finish = (result) => {
                if (!resolved) {
                    resolved = true;
                    cleanup();
                    resolve(result);
                }
            };

            // Mobile Touch Handlers
            const btnM = document.getElementById('match-btn');
            const btnN = document.getElementById('no-match-btn');
            
            btnM.disabled = false;
            btnN.disabled = false;
            
            // Use onclick for universal support (touch/click)
            btnM.onclick = (e) => { e.preventDefault(); finish('match'); };
            btnN.onclick = (e) => { e.preventDefault(); finish('nomatch'); };

            timerId = setTimeout(() => finish('timeout'), ms);
            signal.addEventListener('abort', () => finish('abort'), { once: true });
        });
    }

    endSession() {
        this.running = false;
        document.getElementById('status').innerText = "SESSION END";
        document.getElementById('start-btn').disabled = false;
        document.getElementById('stop-btn').disabled = true;
        document.getElementById('premise-display').style.opacity = '1'; 
    }

    stop() { if (this.abortCtrl) this.abortCtrl.abort(); }
}

const game = new GameEngine();

// IPHONE AUDIO UNLOCK PATTERN
// We must speak immediately inside the click handler to capture the AudioContext.
document.getElementById('start-btn').addEventListener('click', () => {
    // 1. Force cancel any debris
    window.speechSynthesis.cancel();
    
    // 2. Create an immediate utterance to "seize" the audio hardware
    // This effectively wakes up Safari's audio engine.
    const unlock = new SpeechSynthesisUtterance("Starting");
    unlock.volume = 1.0;
    window.speechSynthesis.speak(unlock);

    // 3. Proceed to game logic
    game.n = parseInt(document.getElementById('n-slider').value);
    game.k = parseInt(document.getElementById('k-slider').value);
    game.spt = parseFloat(document.getElementById('spt-slider').value);
    const trials = parseInt(document.getElementById('numTrialsInput').value);
    
    game.runSession(trials);
});

document.getElementById('stop-btn').onclick = () => game.stop();

['n', 'k', 'spt'].forEach(id => {
    document.getElementById(`${id}-slider`).oninput = (e) => 
        document.getElementById(`${id}-value`).innerText = e.target.value;
});

</script>
</body>
</html>
